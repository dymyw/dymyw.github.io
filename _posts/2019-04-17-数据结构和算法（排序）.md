---
layout: post
title: 数据结构和算法（排序）
categories: work tech
tags: structure algorithm
---

简单介绍下排序算法

- 比较排序
    - 交换
        - 冒泡排序
        - 快速排序
    - 插入
        - 简单插入排序
        - 希尔排序
    - 选择
        - 简单选择排序
        - 堆排序
    - 归并
        - 二路归并排序
        - 多路归并排序
- 非比较排序
    - 计数排序
    - 桶排序
    - 基数排序

![]({{ site.baseurl }}/assets/sort_O(x).png)

### 冒泡排序（Bubble Sort）

算法描述

- 比较相邻的元素。如果第一个比第二个大，就交换它们的位置
- 对每一对相邻元素作同样的工作，从开始第一对到结尾最后一对，这样最后的元素就是最大的数
- 针对所有的元素重复以上的步骤，除了最后一个
- 重复步骤 1~3，直到排序完成

动画演示

![]({{ site.baseurl }}/assets/bubble_sort.gif)

golang 实现

```go
func BubbleSort(s []int) []int {
	len := len(s)

	// 控制循环次数
	for i := 0; i < len-1; i++ {
		// 控制每次循环
		for j := 1; j < len-i; j++ {
			if s[j-1] > s[j] {
				s[j-1], s[j] = s[j], s[j-1]
			}
		}
	}

	return s
}
```

算法改进，设置交换变量

``` go
func BubbleSort(s []int) []int {
	len := len(s)

	// 控制循环次数
	for i := 0; i < len-1; i++ {
		// 算法改进，设置交换变量
		exchange := false

		// 控制每次循环
		for j := 1; j < len-i; j++ {
			if s[j-1] > s[j] {
				s[j-1], s[j] = s[j], s[j-1]

				// 发生了交换操作
				if !exchange {
					exchange = true
				}
			}
		}

		// 打印每次循环后的结果
		fmt.Printf("第 %d 次循环结果：%v\n", i+1, s)

		// 如果上一轮没有发生交换数据，证明已经是有序的了，结束排序
		if !exchange {
			break
		}
	}

	return s
}
```
