---
layout: post
title: 数据结构和算法（各种树）
categories: work tech
tags: structure algorithm
---

数据结构中有很多的树，这里对一些常用树的概念和用途做了一些整理

- 二叉树
    - 满二叉树
    - 完全二叉树
- 二叉查找树
- 平衡二叉树
    - 平衡查找树之 AVL树
    - 平衡二叉树之红黑树（Todo）
- B树
    - B+树

### 二叉树

二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构

定义

- 二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点）
- 二叉树的子树有左右之分，次序不能颠倒

![]({{ site.baseurl }}/assets/binary_tree.jpg)

特性

- 二叉树的第 i 层至多有 2<sup>i-1</sup> 个结点，深度为 k 的二叉树至多有 2<sup>k</sup>-1 个结点
- 对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则 n0=n2+1

满二叉树

- 除叶子结点外的所有结点均有两个子结点
- 节点数达到最大值，所有叶子结点必须在同一层上

满二叉树特性

- 一颗树深度为 h，最大层数为 k，深度与最大层数相同 k=h
- 叶子数为 2<sup>h</sup>
- 第 k 层的结点数是：2<sup>k-1</sup>
- 总结点数 2<sup>k</sup>-1，且总节点数一定是奇数

完全二叉树

- 二叉树的深度为 h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数
- 第 h 层所有的结点都连续集中在最左边，这就是完全二叉树

> 完全二叉树是效率很高的数据结构

![]({{ site.baseurl }}/assets/binary_tree_f.png)

### 二叉查找树

又称为是二叉排序树（Binary Sort Tree）或二叉搜索树

二叉排序树或者是一棵空树，或者是具有下列性质的二叉树

- 若左子树不空，则左子树上所有结点的值均小于它的根结点的值
- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值
- 左、右子树也分别为二叉排序树
- 没有键值相等的节点

> 对二叉查找树进行中序遍历，即可得到有序的数列

二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为 O(logn)，但是在最坏的情况下仍然会有 O(n) 的时间复杂度  
原因在于插入和删除元素的时候，树没有保持平衡  
我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷

> 二叉查找树的高度决定了二叉查找树的查找效率

二叉查找树的插入过程如下

- 若当前的二叉查找树为空，则插入的元素为根节点
- 若插入的元素值小于根节点值，则将元素插入到左子树中
- 若插入的元素值不小于根节点值，则将元素插入到右子树中

二叉查找树的删除，分三种情况进行处理

- p 为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点）

![]({{ site.baseurl }}/assets/binary_sort_tree_a.png)

- p 为单支节点（即只有左子树或右子树）让 p 的子树与 p 的父亲节点相连，删除 p 即可（注意分是根节点和不是根节点）

![]({{ site.baseurl }}/assets/binary_sort_tree_b.png)

- p 的左子树和右子树均不空。找到 p 的后继 y，因为 y 一定没有左子树，所以可以删除 y，并让 y 的父亲节点成为 y 的右子树的父亲节点，并用 y 的值代替 p 的值

![]({{ site.baseurl }}/assets/binary_sort_tree_c.png)

### 平衡二叉树

我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为 log2n，其各操作的时间复杂度 O(log2n) 同时也由此而决定  
但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即 O(n)  
我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。于是就有了我们下边介绍的平衡二叉树

平衡二叉树（Balanced Binary Tree）又被称为 AVL树（有别于 AVL算法）

特性

- 它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1
- 并且左右两个子树都是一棵平衡二叉树

> 在平衡二叉搜索树中，其高度一般都良好地维持在 O(log2n)，大大降低了操作的时间复杂度

最小二叉平衡树的节点的公式如下

    F(n)=F(n-1)+F(n-2)+1

类似于一个递归的数列，可以参考 Fibonacci 数列  
1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量

平衡查找树之 AVL树

查找、插入和删除在平均和最坏情况下都是 O(logn)  
增加和删除可能需要通过一次或多次树旋转来重新平衡这个树

这个方案很好的解决了二叉查找树退化成链表的问题
把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在 O(logN)
但是频繁旋转会使插入和删除牺牲掉 O(logN) 左右的时间  
不过相对二叉查找树来说，时间上稳定了很多

旋转

对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差 2

四种情况

![]({{ site.baseurl }}/assets/avl_tree_not_balance.jpg)

- 6 节点的左子树 3 节点高度比右子树 7 节点大 2，左子树 3 节点的左子树 1 节点高度大于右子树 4 节点，这种情况成为左左（单旋转）
- 6 节点的左子树 2 节点高度比右子树 7 节点大 2，左子树 2 节点的左子树 1 节点高度小于右子树 4 节点，这种情况成为左右（双旋转）
- 2 节点的左子树 1 节点高度比右子树 5 节点小 2，右子树 5 节点的左子树 3 节点高度大于右子树 6 节点，这种情况成为右左（双旋转）
- 2 节点的左子树 1 节点高度比右子树 4 节点小 2，右子树 4 节点的左子树 3 节点高度小于右子树 6 节点，这种情况成为右右（单旋转）

单旋转

![]({{ site.baseurl }}/assets/avl_tree_rotate.jpg)

这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵 AVL树  
因为 X 向上一移动了一层，Y 还停留在原来的层面上，Z 向下移动了一层

双旋转

![]({{ site.baseurl }}/assets/avl_tree_rotate_double.jpg)

为使树恢复平衡，第一步，把 k1 作为根，进行一次右右旋转  
第二步，把 k3 作为根，进行一次左左旋转，最后得到了一棵以 k2 为根的平衡二叉树

平衡二叉树之红黑树（Todo）

### B树

B树也是一种用于查找的平衡树，但是它不是二叉树，是一种多路搜索树

![]({{ site.baseurl }}/assets/btree_build.gif)

B+树

B+树的搜索与 B树也基本相同，区别是 B+树只有达到叶子结点才命中（B树可以在非叶子结点命中）  
其性能也等价于在关键字全集做一次二分查找

![]({{ site.baseurl }}/assets/b+tree_build.gif)
